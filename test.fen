extern (add x y)
extern (sub x y)
extern (mul x y)
extern (div x y)
extern (mod x y)
extern (eq x y)
extern (ne x y)
extern (lt x y)
extern (lte x y)
extern (gt x y)
extern (gte x y)
extern (or x y)
extern (and x y)
extern (not x)
extern (bitwiseOr x y)
extern (bitwiseAnd x y)

extern (storeWord ptr value)
extern (loadWord ptr)
extern (storeByte ptr value)
extern (loadByte ptr)

extern (putc char)
extern (putn string length)
extern (getc)

extern (exit code)

extern (open path flags)
extern (close fd)
extern (read fd buffer length)
extern (write fd buffer length)

intern (strlen string)
intern (print string)
intern (printi number base)
intern (scan string n)
intern (printf format argc...)

constant WORD_SIZE = 4

constant O_RDONLY = 0
constant O_WRONLY = 1
constant O_RDWR = 2
constant O_ACCMODE = 3
constant O_APPEND = 2000

public (main argc argv...) {
	(printf "Test int: %i\nTest string: \"%s\"\nTest char: '%c'\n" 13 "Hello World!" 67)
	(exit 0)
}

private (print string) {
	(putn string (strlen string))
}

private (strlen string; len) {
	len := 0
	while (loadByte (add string len)) {
		len := (add len 1)
	}
	return len
}

private (scan buffer n; char) {
	char := (getc)
	while (sub char 10) {
		n := (sub n 1)
		if (lt 0 n) (storeByte buffer char)
		buffer := (add buffer 1)
		char := (getc)
	}
	(storeByte buffer 0)
}

private (printf format args...) {
	while (loadByte format) {
		ifelse (eq (loadByte format) '%') {
			format := (add format 1)
			
			ifelse (eq (loadByte format) 's') {
				(print (loadWord args))
				args := (add args WORD_SIZE)
			} else ifelse (eq (loadByte format) 'i') {
				(printi (loadWord args) 10)
				args := (add args WORD_SIZE)
			} else ifelse (eq (loadByte format) 'c') {
				(putc (loadWord args))
				args := (add args WORD_SIZE)
			} else {
				(putc (loadByte format))
			}
		} else {
			(putc (loadByte format))
		}
		format := (add format 1)
	}
}

private (printi n base; buffer rem) {
	allocate buffer[16]
	(storeByte buffer 0)
	buffer := (add buffer 1)
	
	while (gte n base) {
		rem := (mod n base)
		ifelse (lt rem 10) rem := (add rem 48)
		else rem := (add rem 55)
		(storeByte buffer rem)
		buffer := (add buffer 1)
		
		n := (div n base)
	}
	
	rem := (mod n base)
	ifelse (lt rem 10) rem := (add rem 48)
	else rem := (add rem 55)
	(storeByte buffer rem)
	
	while (loadByte buffer) {
		(putc (loadByte buffer))
		let buffer = (sub buffer 1)
	}
}
